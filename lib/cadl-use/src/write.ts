import {
  getIntrinsicModelName,
  IntrinsicModelName,
  isIntrinsic,
  ModelType,
  Program,
  Type,
} from "@cadl-lang/compiler";
import { OperationDetails } from "@cadl-lang/rest/http";

import prettier from "prettier";

function uncapitalize(s: string): string {
  return s[0].toLowerCase() + s.slice(1);
}

function capitalize(s: string): string {
  return s[0].toUpperCase() + s.slice(1);
}

function camelCasify(s: string): string {
  return uncapitalize(pascalCasify(s));
}

function pascalCasify(s: string): string {
  return s.split(/[-_]/).map(capitalize).join("");
}

export function writeFile(program: Program, details: OperationDetails): string {
  const method = details.verb?.toUpperCase() ?? "GET";

  const requiredParams = details.parameters.parameters.filter(
    (p) => !p.param.optional
  );

  const optionalParams = details.parameters.parameters.filter(
    (p) => p.param.optional
  );

  const queryParams = details.parameters.parameters.filter(
    (p) => p.type === "query"
  );

  if (optionalParams.length > 0) {
    throw new Error("Optional parameters bag not yet supported.");
  }

  let additionalPositionalParams = "";

  for (const p of requiredParams) {
    additionalPositionalParams += `,
    ${camelCasify(p.name)}: ${convertToTypeScript(p.param.type)}`;
  }

  let interfaceDeclarations = "";

  let cachedInterfaceDeclarations = new Map<ModelType, string>();

  let body = "";

  if (details.parameters.body) {
    const bodyModel = details.parameters.body;
    const bodyParamName = camelCasify(bodyModel.name);
    additionalPositionalParams += `,
    ${bodyParamName}: ${convertToTypeScript(
      bodyModel.type,
      pascalCasify(details.operation.name) + "RequestBody"
    )}`;
    body = `,
        body: JSON.stringify(${bodyParamName})`;
  }

  const fragmentReplacer = details.path.replaceAll(/{[a-zA-Z0-9-_]*}/g, (s) => {
    return `\${${camelCasify(s.slice(1, -1))}}`;
  });

  const queryBuilder =
    queryParams.length > 0
      ? `\n    const query = \`?${queryParams
          .map(({ param }) => `${param.name}=\${${camelCasify(param.name)}}`)
          .join("&")}\`;`
      : "";

  const text = `// Generated by Microsoft Cadl

// Requires use of the Azure Identity library
import type { TokenCredential } from "@azure/identity";
${interfaceDeclarations}
export async function ${details.operation.name}(
    baseUrl: URL,
    credential: TokenCredential${additionalPositionalParams}
): Promise<Response> {
    // ${method} ${details.path}
    const path = \`${fragmentReplacer}\`;${queryBuilder}
    const resource = new URL(path + query, baseUrl).toString();

    const authorization = await credential.getToken("https://graph.microsoft.com/.default");

    const init: RequestInit = {
        method: "${method}",
        headers: {
            "Authorization": \`Bearer \${authorization?.token}\`,
            "Content-Type": "application/json"
        }${body}
    };

    const res = await fetch(resource, init);

    return res;
}
`;

  return prettier.format(text);

  function convertToTypeScript(
    t: Type,
    preferredAlternativeName?: string
  ): string {
    if (isIntrinsic(program, t)) {
      const intrinsicName = getIntrinsicModelName(program, t);

      if (intrinsicName === "Map") {
        let [kT, vT] = (t as ModelType).templateArguments!;
        return `{ [k: ${convertToTypeScript(kT)}]: ${convertToTypeScript(vT)}}`;
      }

      return (
        (
          {
            int8: "number",
            int16: "number",
            int32: "number",
            int64: "number",
            uint8: "number",
            uint16: "number",
            uint32: "number",
            uint64: "number",
            float32: "number",
            float64: "number",
            null: "null",
            boolean: "boolean",
            string: "string",
            bytes: "Uint8Array",
          } as Record<IntrinsicModelName, string | undefined>
        )[intrinsicName] ??
        (() => {
          throw new Error(
            "No TypeScript type for CADL intrinsic:" + t.toString()
          );
        })()
      );
    }

    switch (t.kind) {
      case "String":
        return `"${t.value}"`;
      case "Number":
        return t.value.toString();
      case "Array":
        return `${convertToTypeScript(t.elementType)}[]`;
      case "Model":
        return addInterface(t, preferredAlternativeName);
      default:
        throw new Error("Unknown type " + t.kind);
    }
  }

  function addInterface(
    tOriginal: ModelType,
    preferredAlternativeName?: string
  ): string {
    if (cachedInterfaceDeclarations.has(tOriginal))
      return cachedInterfaceDeclarations.get(tOriginal)!;

    const t = program.checker.getEffectiveModelType(tOriginal);

    const name = t.name !== "" ? t.name : preferredAlternativeName;

    if (!name) {
      throw new Error("Unable to ascertain interface name.");
    }

    const extendsClause =
      t.baseModel !== undefined
        ? ` extends ${convertToTypeScript(t.baseModel)}`
        : "";

    const fields = [...t.properties.values()].map(
      (p) =>
        `\n    ${p.name}${p.optional ? "?" : ""}: ${convertToTypeScript(
          p.type
        )}`
    );

    const declaration = `\ninterface ${name}${extendsClause} {${fields}}\n`;

    interfaceDeclarations += declaration;

    cachedInterfaceDeclarations.set(tOriginal, name);

    return name;
  }
}
